---
title: "sl_proj_2"
author: "Michele Maslowski"
date: "2025-04-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


rm(list = ls()) #Clear workspace

library("tidyverse")          #For data manipulation
library("ggplot2")            #For nice plots
library('Metrics')
library('gridExtra')
library('dplyr')
library("ISLR")
library("glmnet")
library("MASS")
library("caret")
library("splines")
library("boot")
library("class")
library("nnet")
library('Rmpfr')
library('reshape2')
library('pROC')
```

```{r Load in data}

data <- read.csv("C:/Users/mmasl/OneDrive - Marquette University/Desktop/Statistical Learning/midterm_proj_2_code/spotify-2023.csv", header = TRUE, sep = ",")


data$streams <- as.numeric(data$streams)
mean <- mean(data$streams, na.rm = TRUE)

# data cleaning
data <- data %>%
  mutate(average_streams = case_when(
    streams >= mean(streams, na.rm = TRUE) ~ 1,  # Use the actual computed mean
    streams <= mean(streams, na.rm = TRUE) ~ 0,  # Use the actual computed mean
    TRUE ~ NA_real_  # Default case for unexpected values
  ))

```

```{r Looking at Data}
cleaned <- dplyr::select(data, -key, -artist.s._name, -track_name, -in_deezer_playlists, -in_shazam_charts, -mode, -streams)

cor_matrix <- cor(cleaned, use = "complete.obs", method = "pearson")
cor_matrix_melted <- melt(cor_matrix)

# Plot the heatmap with correlation numbers using ggplot2
ggplot(cor_matrix_melted, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "black", high = "green", mid = "white", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = NULL, y = NULL, fill = "Correlation") +
  geom_text(aes(label = round(value, 2)), color = "black", size = 3)

```

```{r Test/ Train Split}
set.seed(1)

# training and test split 80% train 20% test
train_indices <- sample(1:nrow(cleaned), size = 0.8 * nrow(cleaned))

# split
train_data <- cleaned[train_indices, ]
test_data <- cleaned[-train_indices, ]

test_label <- as.factor(test_data$average_streams)
test_data <- dplyr::select(test_data, -average_streams)

```

```{r Logistic Regression}

log_regress <- glm(average_streams ~ ., data = train_data, family = binomial)

summary(log_regress)

predict_log_prob <- predict(log_regress, newdata = test_data, type = "response")

predict_log <- as.factor(ifelse(predict_log_prob > 0.5, 1, 0))

conf_matrix <- confusionMatrix(predict_log, test_label)

conf_matrix_df <- as.data.frame(as.table(conf_matrix))

# Melt the confusion matrix for ggplot
conf_matrix_melt <- melt(conf_matrix_df, id.vars = c("Reference", "Prediction"))

ggplot(conf_matrix_melt, aes(x = Reference, y = Prediction, fill = value)) +
  geom_tile() +
  geom_text(aes(label = value), color = "black", size = 6) +
  scale_fill_gradient(low = "gray", high = "green") +
  theme_minimal() +
  labs(title = "Confusion Matrix for Logistic Regression", x = "Actual", y = "Predicted")

roc_curve <- roc(test_label, predict_log_prob)
plot(roc_curve)
auc(roc_curve)

test_label_numeric <- as.numeric(as.character(test_label))  # Convert factors to numeric
predict_log_numeric <- as.numeric(as.character(predict_log))  # Convert factors to numeric

# Calculate Mean Squared Error (MSE)
mse <- mean((test_label_numeric - predict_log_numeric)^2)
```

```{r}
set.seed(123)
x <- seq(-10, 10, length.out = 100)
prob <- 1 / (1 + exp(-0.8 * x + 1))
y <- rbinom(100, size = 1, prob = prob)

# Fit logistic regression model
data <- data.frame(x = x, y = y)
model <- glm(y ~ x, data = data, family = binomial)

# Predict probabilities for plotting
x_vals <- seq(min(x), max(x), length.out = 300)
predicted_probs <- predict(model, newdata = data.frame(x = x_vals), type = "response")

# Set blue background
par(bg = "blue")

# Create empty plot
plot(x_vals, predicted_probs, type = "n", main = "Logistic Regression Fit",
     xlab = "X", ylab = "Probability", ylim = c(0, 1))

# Add THICK logistic regression curve
lines(x_vals, predicted_probs, col = "red", lwd = 4)

```
